Here's a series of 8 NASM assembly examples demonstrating different addressing modes and basic instructions:

## **1. Register Direct Addressing**
```nasm
section .text
global _start

_start:
    ; Register direct - operating directly on registers
    mov eax, 10         ; EAX = 10
    mov ebx, 20         ; EBX = 20
    add eax, ebx        ; EAX = EAX + EBX (30)
    
    ; Exit
    mov eax, 1
    int 0x80
```

## **2. Immediate Addressing**  
```nasm
section .text
global _start

_start:
    ; Immediate - using constant values directly
    mov eax, 100        ; EAX = 100 (immediate value)
    add ebx, 15         ; EBX = EBX + 15
    sub ecx, 25         ; ECX = ECX - 25
    
    mov eax, 1
    int 0x80
```

## **3. Direct Memory Addressing**
```nasm
section .data
    number  dd 42       ; Define doubleword (4 bytes)
    result  dd 0

section .text
global _start

_start:
    ; Direct memory - accessing variables by name
    mov eax, [number]   ; EAX = value at 'number' address (42)
    add eax, 10
    mov [result], eax   ; Store result in memory
    
    mov eax, 1
    int 0x80
```

## **4. Register Indirect Addressing**
```nasm
section .data
    array dd 10, 20, 30, 40
    len   equ ($ - array) / 4

section .text
global _start

_start:
    ; Register indirect - using register as pointer
    mov esi, array      ; ESI points to array start
    mov eax, [esi]      ; EAX = first element (10)
    
    add esi, 4          ; Move to next element (+4 bytes)
    mov ebx, [esi]      ; EBX = second element (20)
    
    mov eax, 1
    int 0x80
```

## **5. Base + Displacement Addressing**
```nasm
section .data
    values dd 100, 200, 300, 400

section .text
global _start

_start:
    ; Base + displacement - register + offset
    mov ebx, values     ; EBX = base address
    
    mov eax, [ebx]      ; EAX = values[0] (100)
    mov ecx, [ebx + 4]  ; ECX = values[1] (200)  
    mov edx, [ebx + 8]  ; EDX = values[2] (300)
    
    mov eax, 1
    int 0x80
```

## **6. Indexed Addressing**
```nasm
section .data
    numbers dd 5, 15, 25, 35, 45

section .text
global _start

_start:
    ; Indexed addressing - using index register
    mov esi, 3          ; Index = 3
    mov eax, [numbers + esi*4]  ; EAX = numbers[3] (35)
    ; esi*4 because each integer is 4 bytes
    
    ; Loop through array
    mov ecx, 5          ; Counter
    mov esi, 0          ; Index
loop_start:
    mov eax, [numbers + esi*4]  ; Get numbers[i]
    add esi, 1
    loop loop_start
    
    mov eax, 1
    int 0x80
```

## **7. Base + Index Addressing**
```nasm
section .data
    matrix times 16 dd 0   ; 4x4 matrix

section .text
global _start

_start:
    ; Base + Index - for 2D arrays
    mov ebx, matrix     ; Base = matrix start
    mov esi, 2          ; Row index = 2
    mov edi, 3          ; Column index = 3
    
    ; Calculate address: matrix[row][col] = base + (row*4 + col)*4
    mov eax, esi        ; Row
    mov ecx, 4          ; 4 columns per row
    mul ecx             ; EAX = row * 4
    add eax, edi        ; + column
    mov ecx, 4
    mul ecx             ; *4 (each element 4 bytes)
    
    mov dword [ebx + eax], 99  ; matrix[2][3] = 99
    
    mov eax, 1
    int 0x80
```

## **8. Complex Example: String Copy**
```nasm
section .data
    source db "Hello, Assembly!", 0
    dest   times 20 db 0

section .text
global _start

_start:
    ; Demonstrate multiple addressing modes in one program
    mov esi, source     ; Source pointer (register indirect)
    mov edi, dest       ; Destination pointer
    
copy_loop:
    mov al, [esi]       ; Load byte from source (register indirect)
    mov [edi], al       ; Store byte to dest (register indirect)
    
    cmp al, 0           ; Check for null terminator (immediate)
    je done
    
    add esi, 1          ; Increment pointers (immediate)
    add edi, 1
    jmp copy_loop

done:
    ; Exit
    mov eax, 1
    int 0x80
```

---

## **Quick Reference: Addressing Modes**

* Addressing modes
- Register Direct: `mov eax, ebx`
- Immediate: `mov eax, 100`  
- Direct Memory: `mov eax, [variable]`
- Register Indirect: `mov eax, [esi]`
- Base + Displacement: `mov eax, [ebx + 8]`
- Indexed: `mov eax, [array + esi*4]`
- Base + Index: `mov eax, [ebx + esi*4]`


* gdb with nasm
** command-line
nasm -f elf64 -g -F dwarf program.asm
ld -o program program.o
** Interacting with gdb
# Start and stop
(gdb) break _start      # Set breakpoint at start
(gdb) run               # Start program
(gdb) quit              # Exit gdb

# Examine registers
(gdb) info registers    # Show ALL registers
(gdb) print $rax        # Show RAX value
(gdb) print $ebx        # Show EBX value
(gdb) print $rsp        # Show stack pointer

# Step through code
(gdb) stepi             # Step one instruction
(gdb) nexti             # Step over function calls
(gdb) continue          # Continue execution

# Examine memory
(gdb) x/10x $rsp        # Examine 10 words at stack pointer
(gdb) x/s 0x4000        # Examine as string at address

** Useful GDB Configuration

Create .gdbinit file for better assembly debugging with following lines:

set disassembly-flavor intel
layout regs

Or you could set this interactively in a session as:
(gdb) set disassembly-flavor intel
(gdb) layout regs        # Show registers window
(gdb) layout asm         # Show assembly code window
** Advanced setups
# Watchpoints - break when register/memory changes
(gdb) watch $rax
(gdb) watch *0x600000

# Display registers automatically
(gdb) display $rax
(gdb) display $rbx

# Disassembly
(gdb) disassemble _start

# Examine specific memory regions
(gdb) x/8xb &number      # 8 bytes in hex
(gdb) x/4xw &number      # 4 words in hex
(gdb) x/d &number        # As decimal

# TUI mode for better visualization
(gdb) tui enable
(gdb) layout split       # Code and registers

x/10x $rsp            - Examine 10 hexadecimal words at stack
x/4xw &variable       - Examine 4 words at variable address  
x/s 0x4000            - Examine memory as null-terminated string
x/d &number           - Examine memory as decimal value

few more:
# Most commonly used:
x/4dw &data      # 4 integers as decimal
x/10db $rsp      # 10 bytes as decimal from stack

# For specific sizes:
x/8db  - 8 bytes as decimal
x/4dh  - 4 halfwords (2-byte) as decimal  
x/2dw  - 2 words (4-byte) as decimal
x/1dg  - 1 giant word (8-byte) as decimal

** Sample session
